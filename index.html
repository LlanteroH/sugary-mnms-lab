import React, { useEffect, useMemo, useRef, useState } from "react";

/**
 * Sugary M&Ms — Interactive Lab (Teacher‑locked steps)
 * - Students must complete each step in order.
 * - If they try something out of order or incorrect (e.g., sugar in the "No sugar" cup),
 *   the action is blocked and a corrective message appears.
 * - Previous steps are locked once completed; use Reset to restart.
 */

export default function SugaryMAndMsLab_Locked() {
  // ---------- Constants ----------
  const LABELS = [
    { id: "no", text: "No sugar", sugarTeaspoons: 0 },
    { id: "1tsp", text: "1 tsp sugar", sugarTeaspoons: 1 },
    { id: "3tsp", text: "3 tsp sugar", sugarTeaspoons: 3 },
  ];
  const MM_COLORS = [
    { id: "red", name: "Red", rgb: [220, 38, 38] },
    { id: "blue", name: "Blue", rgb: [37, 99, 235] },
    { id: "green", name: "Green", rgb: [16, 185, 129] },
    { id: "yellow", name: "Yellow", rgb: [234, 179, 8] },
    { id: "orange", name: "Orange", rgb: [249, 115, 22] },
    { id: "brown", name: "Brown", rgb: [87, 55, 40] },
  ];
  const STEP_TEXT = {
    1: "Label 3 cups and 3 plates",
    2: "Add ¼ cup water to each cup",
    3: "Add sugar to the 1‑tsp and 3‑tsp cups",
    4: "Stir until sugar dissolves",
    5: "Pour each cup into its matching plate",
    6: "Add an M&M to each plate",
  };

  // ---------- Types ----------
  /** @typedef {{ id: string, labelId: string|null, water: number, sugar: number, dissolved: boolean }} Cup */
  /** @typedef {{ id: string, labelId: string|null, solutionWater: number, solutionSugar: number, mmColorId: string|null, simTime: number, running: boolean }} Plate */

  // ---------- State ----------
  const [cups, setCups] = useState(() =>
    Array.from({ length: 3 }, (_, i) => ({ id: `cup-${i + 1}`, labelId: null, water: 0, sugar: 0, dissolved: false }))
  );
  const [plates, setPlates] = useState(() =>
    Array.from({ length: 3 }, (_, i) => ({ id: `plate-${i + 1}`, labelId: null, solutionWater: 0, solutionSugar: 0, mmColorId: null, simTime: 0, running: false }))
  );
  const [labelPool] = useState(() =>
    LABELS.map((l) => ({ ...l, poolId: `cup-${l.id}` })).concat(LABELS.map((l) => ({ ...l, poolId: `plate-${l.id}` })))
  );
  const [message, setMessage] = useState("");
  const [speed, setSpeed] = useState(10);
  const [notes, setNotes] = useState({ predictions: "", observations: "", explanations: "" });

  // ---------- Helpers ----------
  const getLabel = (labelId) => LABELS.find((l) => l.id === labelId) || null;
  const labelText = (labelId) => getLabel(labelId)?.text || "—";
  function postMessage(text) {
    setMessage(text);
    if (!text) return;
    clearTimeout((postMessage)._t);
    (postMessage)._t = setTimeout(() => setMessage(""), 3000);
  }

  function onDragStart(e, payload) {
    e.dataTransfer.setData("application/json", JSON.stringify(payload));
  }
  function readPayload(e) {
    try { return JSON.parse(e.dataTransfer.getData("application/json")); } catch { return null; }
  }

  // ---------- Step calculation & gating ----------
  const stepFlags = useMemo(() => {
    const labelsDone = cups.every((c) => c.labelId) && plates.every((p) => p.labelId);
    const waterDone = cups.every((c) => c.water >= 0.25);
    const sugarDone = LABELS.every((lab) => {
      const cup = cups.find((c) => c.labelId === lab.id);
      if (!cup) return false;
      return cup.sugar === lab.sugarTeaspoons;
    });
    const dissolvedDone = cups.every((c) => (c.sugar > 0 ? c.dissolved : true));
    const pouredDone = plates.every((p) => p.solutionWater >= 0.25);
    const mmPlaced = plates.every((p) => p.mmColorId);
    const current = !labelsDone ? 1 : !waterDone ? 2 : !sugarDone ? 3 : !dissolvedDone ? 4 : !pouredDone ? 5 : 6;
    return { labelsDone, waterDone, sugarDone, dissolvedDone, pouredDone, mmPlaced, current };
  }, [cups, plates]);

  function requireStep(required) {
    const cur = stepFlags.current;
    if (cur < required) {
      postMessage(`Not yet — complete Step ${cur}: ${STEP_TEXT[cur]}.`);
      return false;
    }
    // lock earlier steps after you advance
    if (required < cur) {
      if (required === 1) postMessage("Labels are locked after Step 1. Use Reset to restart.");
      if (required === 2) postMessage("Water step is locked after Step 2. Use Reset to change water.");
      return false;
    }
    return true;
  }

  // ---------- Label Drops (Step 1 only) ----------
  function handleLabelDropOnCup(cupId, e) {
    e.preventDefault();
    if (!requireStep(1)) return;
    const p = readPayload(e); if (!p || p.type !== "label") return;
    setCups((prev) => prev.map((c) => (c.id === cupId ? { ...c, labelId: p.labelId } : c)));
  }
  function handleLabelDropOnPlate(plateId, e) {
    e.preventDefault();
    if (!requireStep(1)) return;
    const p = readPayload(e); if (!p || p.type !== "label") return;
    setPlates((prev) => prev.map((pl) => (pl.id === plateId ? { ...pl, labelId: p.labelId } : pl)));
  }

  // ---------- Water & Sugar on Cups ----------
  function handleCupDrop(cupId, e) {
    e.preventDefault();
    const p = readPayload(e); if (!p) return;
    const cup = cups.find((c) => c.id === cupId); if (!cup) return;

    if (p.type === "water") {
      if (!requireStep(2)) return;
      if (!cup.labelId) return postMessage("Label this cup before adding water.");
      if (cup.water >= 0.25) return postMessage("This cup already has ¼ cup water.");
      setCups((prev) => prev.map((c) => (c.id === cupId ? { ...c, water: 0.25 } : c)));
      return;
    }

    if (p.type === "sugar") {
      if (!requireStep(3)) return;
      if (!cup.labelId) return postMessage("Label this cup before adding sugar.");
      if (cup.water < 0.25) return postMessage("Add ¼ cup water to this cup before sugar.");
      const lab = getLabel(cup.labelId); const required = lab ? lab.sugarTeaspoons : 0;
      if (required === 0) return postMessage("The 'No sugar' cup should not get sugar.");
      const remaining = required - cup.sugar;
      if (remaining <= 0) return postMessage(`This cup already has the required ${required} tsp sugar.`);
      if (p.amount > remaining) return postMessage(`Too much sugar. This cup needs exactly ${remaining} more tsp.`);
      setCups((prev) => prev.map((c) => (c.id === cupId ? { ...c, sugar: c.sugar + p.amount, dissolved: false } : c)));
      return;
    }
  }

  // ---------- Stir to Dissolve (Step 4) ----------
  function stirCup(cupId) {
    if (!requireStep(4)) return;
    const c = cups.find((x) => x.id === cupId); if (!c) return;
    if (c.water <= 0) return postMessage("Add water first (¼ cup).");
    if (c.sugar <= 0) return postMessage("No sugar to dissolve in this cup.");
    postMessage("Stirring… dissolving sugar");
    setTimeout(() => {
      setCups((prev) => prev.map((x) => (x.id === cupId ? { ...x, dissolved: true } : x)));
      postMessage("Sugar dissolved!");
    }, Math.max(600, 800 + c.sugar * 300));
  }

  // ---------- Pour Cup onto Plate (Step 5) ----------
  function onCupDragStart(e, cupId) { onDragStart(e, { type: "cup", cupId }); }
  function onPlateDrop(plateId, e) {
    e.preventDefault();
    const p = readPayload(e); if (!p || p.type !== "cup") return;
    if (!requireStep(5)) return;
    const cup = cups.find((c) => c.id === p.cupId); if (!cup) return;
    if (!cup.labelId) return postMessage("Label the cup before pouring.");
    const plate = plates.find((pl) => pl.id === plateId); if (!plate) return;
    if (!plate.labelId) return postMessage("Label the plate before pouring.");
    if (plate.labelId !== cup.labelId) return postMessage("Pour into the matching labeled plate.");
    if (cup.water <= 0) return postMessage("This cup is empty — add water.");
    if (cup.sugar > 0 && !cup.dissolved) return postMessage("Stir until sugar dissolves before pouring.");

    setPlates((prev) => prev.map((pl) => pl.id === plateId ? {
      ...pl,
      solutionWater: parseFloat((pl.solutionWater + cup.water).toFixed(2)),
      solutionSugar: pl.solutionSugar + cup.sugar,
    } : pl));
    setCups((prev) => prev.map((c) => (c.id === cup.id ? { ...c, water: 0, sugar: 0, dissolved: false } : c)));
    postMessage("Poured into plate.");
  }

  // ---------- M&M Placement & Simulation (Step 6) ----------
  function onMMDrop(plateId, e) {
    e.preventDefault();
    const p = readPayload(e); if (!p || p.type !== "mm") return;
    if (!requireStep(6)) return;
    const plate = plates.find((pl) => pl.id === plateId); if (!plate) return;
    if (plate.solutionWater <= 0) return postMessage("Pour the solution into this plate first.");
    setPlates((prev) => prev.map((pl) => pl.id === plateId ? { ...pl, mmColorId: p.mmColorId, running: true, simTime: 0 } : pl));
  }

  // diffusion tick
  useEffect(() => {
    const t = setInterval(() => {
      setPlates((prev) => prev.map((pl) => pl.running ? { ...pl, simTime: pl.simTime + 0.1 * speed } : pl));
    }, 100);
    return () => clearInterval(t);
  }, [speed]);

  function resetPlateSim(plateId) {
    setPlates((prev) => prev.map((pl) => pl.id === plateId ? { ...pl, mmColorId: null, simTime: 0, running: false } : pl));
  }
  function resetAll() {
    setCups(Array.from({ length: 3 }, (_, i) => ({ id: `cup-${i + 1}`, labelId: null, water: 0, sugar: 0, dissolved: false })));
    setPlates(Array.from({ length: 3 }, (_, i) => ({ id: `plate-${i + 1}`, labelId: null, solutionWater: 0, solutionSugar: 0, mmColorId: null, simTime: 0, running: false })));
    setNotes({ predictions: "", observations: "", explanations: "" });
    setSpeed(10);
    postMessage("Reset the lab.");
  }

  // ---------- UI ----------
  return (
    <div className="w-full min-h-[100vh] bg-gradient-to-b from-slate-50 to-slate-100 text-slate-800">
      <div className="max-w-7xl mx-auto p-4 md:p-6 lg:p-8">
        <header className="flex items-start justify-between gap-4">
          <div>
            <h1 className="text-2xl md:text-3xl font-bold">Sugary M&amp;Ms — Interactive Lab (Teacher‑locked steps)</h1>
            <p className="text-sm md:text-base text-slate-600 mt-1">Students must complete each step in order. Incorrect actions are blocked with corrective hints.</p>
          </div>
          <div className="flex items-center gap-3">
            <label className="text-sm">Time speed</label>
            <input type="range" min={1} max={30} step={1} value={speed} onChange={(e) => setSpeed(parseInt(e.target.value))} className="w-40" aria-label="Simulation speed" />
            <span className="text-sm w-10 text-right">{speed}×</span>
            <button onClick={resetAll} className="px-3 py-2 rounded-xl bg-slate-800 text-white text-sm hover:bg-slate-700">Reset</button>
          </div>
        </header>

        <Steps status={stepFlags} />

        <section className="mt-6 grid grid-cols-1 lg:grid-cols-12 gap-6">
          <div className="lg:col-span-3">
            <ToolTray onDragStart={onDragStart} MM_COLORS={MM_COLORS} />
            <LabelTray labelPool={labelPool} onDragStart={onDragStart} />
            <NotesPanel notes={notes} setNotes={setNotes} />
          </div>

          <div className="lg:col-span-9 grid grid-cols-1 md:grid-cols-2 gap-6">
            <CupBoard cups={cups} onLabelDrop={handleLabelDropOnCup} onCupDrop={handleCupDrop} onCupDragStart={onCupDragStart} stirCup={stirCup} labelText={labelText} />
            <PlateBoard plates={plates} onLabelDrop={handleLabelDropOnPlate} onCupDropOnPlate={onPlateDrop} onMMDrop={onMMDrop} resetPlateSim={resetPlateSim} labelText={labelText} MM_COLORS={MM_COLORS} />
          </div>
        </section>

        {message && (
          <div className="fixed bottom-4 left-1/2 -translate-x-1/2 bg-slate-900 text-white px-4 py-2 rounded-xl shadow-xl">{message}</div>
        )}

        <section className="mt-8">
          <h3 className="font-semibold text-lg">Conceptual prompts</h3>
          <ul className="list-disc pl-6 text-sm md:text-base mt-2 space-y-1 text-slate-700">
            <li>Compare how fast the color spreads on each plate. Which plate’s color reaches the edge first? Which last?</li>
            <li>Describe the sharpness of the color boundary on each plate. How does sugar concentration affect mixing?</li>
            <li>Explain using particle motion and concentration gradients why a higher sugar solution might slow spreading.</li>
            <li>Predict what would happen with even more sugar (e.g., 5 tsp). What about warm vs. cold water?</li>
          </ul>
        </section>
      </div>
    </div>
  );
}

// ---------- Components ----------
function Steps({ status }) {
  const steps = [
    { key: "labelsDone", text: "Label 3 cups + 3 plates (No sugar, 1 tsp sugar, 3 tsp sugar)" },
    { key: "waterDone", text: "Add ¼ cup water to each cup" },
    { key: "sugarDone", text: "Add sugar to the 1‑tsp and 3‑tsp cups" },
    { key: "dissolvedDone", text: "Stir until sugar dissolves" },
    { key: "pouredDone", text: "Pour each cup into its matching plate" },
    { key: "mmPlaced", text: "Add an M&M to each plate; watch and record observations" },
  ];
  const cur = status.current;
  return (
    <ol className="mt-4 grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-3">
      {steps.map((s, i) => (
        <li key={s.key} className={`flex items-start gap-2 p-3 rounded-xl border ${status[s.key] ? "border-emerald-400 bg-emerald-50" : i + 1 === cur ? "border-amber-400 bg-amber-50" : "border-slate-200 bg-white"}`}>
          <span className={`mt-1 inline-flex h-5 w-5 shrink-0 items-center justify-center rounded-full text-xs font-bold ${status[s.key] ? "bg-emerald-500 text-white" : i + 1 === cur ? "bg-amber-500 text-white" : "bg-slate-200 text-slate-700"}`}>{i + 1}</span>
          <span className="text-sm md:text-base">{s.text}</span>
        </li>
      ))}
    </ol>
  );
}

function ToolTray({ onDragStart, MM_COLORS }) {
  return (
    <div className="p-4 rounded-2xl bg-white border border-slate-200 shadow-sm">
      <h3 className="font-semibold">Tools</h3>
      <p className="text-xs text-slate-500 mb-3">Drag these onto cups/plates.</p>
      <div className="space-y-3">
        <div className="flex items-center gap-3">
          <div draggable onDragStart={(e) => onDragStart(e, { type: "water" })} className="select-none cursor-grab active:cursor-grabbing px-3 py-2 rounded-xl bg-sky-100 border border-sky-300 text-sky-900 text-sm shadow-sm" title="Drag to add ¼ cup water to a cup">Water pitcher (¼ cup)</div>
          <div draggable onDragStart={(e) => onDragStart(e, { type: "sugar", amount: 1 })} className="select-none cursor-grab active:cursor-grabbing px-3 py-2 rounded-xl bg-amber-100 border border-amber-300 text-amber-900 text-sm shadow-sm" title="Drag to add 1 tsp sugar to a cup">Sugar spoon (1 tsp)</div>
        </div>
        <div>
          <h4 className="text-sm font-medium mb-2">M&amp;Ms</h4>
          <div className="flex flex-wrap gap-2">
            {MM_COLORS.map((c) => (
              <button key={c.id} draggable onDragStart={(e) => onDragStart(e, { type: "mm", mmColorId: c.id })} className="w-8 h-8 rounded-full border border-slate-300 shadow-sm cursor-grab active:cursor-grabbing" style={{ backgroundColor: `rgb(${c.rgb[0]}, ${c.rgb[1]}, ${c.rgb[2]})` }} title={`Drag a ${c.name} M&M onto a plate`} />
            ))}
          </div>
        </div>
      </div>
    </div>
  );
}

function LabelTray({ labelPool, onDragStart }) {
  return (
    <div className="p-4 mt-4 rounded-2xl bg-white border border-slate-200 shadow-sm">
      <h3 className="font-semibold">Labels</h3>
      <p className="text-xs text-slate-500 mb-3">Drag onto cups and plates.</p>
      <div className="grid grid-cols-1 gap-2">
        {labelPool.map((l, idx) => (
          <div key={`${l.poolId}-${idx}`} draggable onDragStart={(e) => onDragStart(e, { type: "label", labelId: l.id })} className="px-3 py-2 rounded-xl bg-slate-50 border text-sm border-slate-200 hover:bg-slate-100 cursor-grab active:cursor-grabbing">
            {l.text} <span className="text-xs text-slate-400">({l.poolId.includes("cup") ? "cup" : "plate"} label)</span>
          </div>
        ))}
      </div>
    </div>
  );
}

function CupBoard({ cups, onLabelDrop, onCupDrop, onCupDragStart, stirCup, labelText }) {
  return (
    <div className="p-4 rounded-2xl bg-white border border-slate-200 shadow-sm">
      <h3 className="font-semibold mb-3">Cups</h3>
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
        {cups.map((c) => (
          <div key={c.id} className="relative">
            <div className="rounded-2xl p-3 border border-slate-200 bg-slate-50" onDragOver={(e) => e.preventDefault()} onDrop={(e) => handleCupDropComposite(e, c.id, onLabelDrop, onCupDrop)}>
              <div className="flex items-center justify-between gap-2">
                <span className="text-xs text-slate-500">{c.id}</span>
                <div draggable onDragStart={(e) => onCupDragStart(e, c.id)} className="text-xs px-2 py-1 rounded-lg bg-slate-200 border border-slate-300 cursor-grab active:cursor-grabbing" title="Drag this cup onto a matching plate to pour">Drag to pour</div>
              </div>
              <div className="mt-2">
                <div className="text-sm font-medium">Label: <span className="font-normal">{labelText(c.labelId)}</span></div>
                <div className="text-sm">Water: <span className="font-semibold">{c.water.toFixed(2)} cup</span></div>
                <div className="text-sm">Sugar: <span className="font-semibold">{c.sugar} tsp</span> {c.sugar > 0 && (<span className={`ml-1 text-xs px-1.5 py-0.5 rounded ${c.dissolved ? "bg-emerald-100 text-emerald-700" : "bg-amber-100 text-amber-700"}`}>{c.dissolved ? "dissolved" : "undissolved"}</span>)}</div>
              </div>
              <div className="mt-3 flex gap-2 text-xs">
                <span className="px-2 py-1 rounded-lg bg-sky-50 border border-sky-200">Drop: water / sugar / label</span>
                <button onClick={() => stirCup(c.id)} className="ml-auto px-2 py-1 rounded-lg bg-slate-800 text-white hover:bg-slate-700">Stir</button>
              </div>
              <div className="mt-3 h-28 rounded-xl border border-slate-200 bg-white overflow-hidden grid place-items-center">
                <CupVisual water={c.water} sugar={c.sugar} dissolved={c.dissolved} />
              </div>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}

function handleCupDropComposite(e, cupId, onLabelDrop, onCupDrop) {
  const p = (() => { try { return JSON.parse(e.dataTransfer.getData("application/json")); } catch { return null; } })();
  if (!p) return;
  if (p.type === "label") return onLabelDrop(cupId, e);
  return onCupDrop(cupId, e);
}

function CupVisual({ water, sugar, dissolved }) {
  const waterPct = Math.min(1, water / 0.25);
  return (
    <div className="w-[90%] h-[90%] border border-slate-300 rounded-xl relative overflow-hidden bg-slate-50">
      <div className="absolute bottom-0 left-0 right-0 transition-all" style={{ height: `${waterPct * 100}%`, background: `linear-gradient(to top, rgba(56,189,248,0.35), rgba(56,189,248,0.2))` }} />
      {sugar > 0 && (
        <div className="absolute bottom-1 left-1 text-[10px] px-1 py-0.5 rounded bg-amber-100 text-amber-800 border border-amber-300">{dissolved ? "Sugar dissolved" : "Sugar crystals"}</div>
      )}
    </div>
  );
}

function PlateBoard({ plates, onLabelDrop, onCupDropOnPlate, onMMDrop, resetPlateSim, labelText, MM_COLORS }) {
  return (
    <div className="p-4 rounded-2xl bg-white border border-slate-200 shadow-sm">
      <h3 className="font-semibold mb-3">Plates</h3>
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
        {plates.map((p) => (
          <div key={p.id} className="relative">
            <div className="rounded-2xl p-3 border border-slate-200 bg-slate-50" onDragOver={(e) => e.preventDefault()} onDrop={(e) => handlePlateDropComposite(e, p.id, onLabelDrop, onCupDropOnPlate, onMMDrop)}>
              <div className="flex items-center justify-between gap-2">
                <span className="text-xs text-slate-500">{p.id}</span>
                <div className="text-xs px-2 py-1 rounded-lg bg-slate-200 border border-slate-300">Drop: label / CUP / M&amp;M</div>
              </div>
              <div className="mt-2 grid grid-cols-2 gap-2 text-sm">
                <div>Label: <span className="font-medium">{labelText(p.labelId)}</span></div>
                <div>Solution: <span className="font-semibold">{p.solutionWater.toFixed(2)} cup</span></div>
                <div>Sugar: <span className="font-semibold">{p.solutionSugar} tsp</span></div>
                <div>M&amp;M: <span className="font-medium">{p.mmColorId ? p.mmColorId : "—"}</span></div>
              </div>
              <div className="mt-3 h-64 rounded-xl border border-slate-200 bg-white overflow-hidden grid place-items-center">
                <PlateVisual plate={p} MM_COLORS={MM_COLORS} />
              </div>
              <div className="mt-3 flex items-center gap-2 text-xs">
                <button onClick={() => resetPlateSim(p.id)} className="ml-auto px-2 py-1 rounded-lg bg-slate-800 text-white hover:bg-slate-700">Reset plate</button>
              </div>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}

function handlePlateDropComposite(e, plateId, onLabelDrop, onCupDropOnPlate, onMMDrop) {
  const p = (() => { try { return JSON.parse(e.dataTransfer.getData("application/json")); } catch { return null; } })();
  if (!p) return;
  if (p.type === "label") return onLabelDrop(plateId, e);
  if (p.type === "cup") return onCupDropOnPlate(plateId, e);
  if (p.type === "mm") return onMMDrop(plateId, e);
}

function PlateVisual({ plate, MM_COLORS }) {
  const size = 220; const radius = size / 2 - 6;
  const sugar = plate.solutionSugar; const baseK = 8; const k = baseK;
  const r = Math.min(radius, k * Math.sqrt(Math.max(0, plate.simTime)) / (1 + 0.6 * sugar));
  const softness = Math.max(6, 22 - sugar * 6);
  const color = MM_COLORS.find((c) => c.id === plate.mmColorId)?.rgb || [120, 120, 120];
  const waterTint = plate.solutionWater > 0 ? 0.15 : 0; const gradientId = `${plate.id}-grad`;
  return (
    <svg width={size} height={size} className="drop-shadow-sm">
      <defs>
        <radialGradient id={gradientId} cx="50%" cy="50%" r="50%">
          <stop offset={`${Math.max(0, ((r - softness) / radius) * 100)}%`} stopColor={`rgba(${color[0]}, ${color[1]}, ${color[2]}, 0.85)`} />
          <stop offset={`${Math.max(0, (r / radius) * 100)}%`} stopColor={`rgba(${color[0]}, ${color[1]}, ${color[2]}, 0.5)`} />
          <stop offset={`${Math.min(100, ((r + softness) / radius) * 100)}%`} stopColor={`rgba(${color[0]}, ${color[1]}, ${color[2]}, 0.0)`} />
        </radialGradient>
      </defs>
      <circle cx={size / 2} cy={size / 2} r={radius} fill={`rgba(56,189,248,${waterTint})`} stroke="#cbd5e1" strokeWidth={3} />
      {plate.mmColorId && <circle cx={size / 2} cy={size / 2} r={radius} fill={`url(#${gradientId})`} />}
      <circle cx={size / 2} cy={size / 2} r={10} fill={plate.mmColorId ? `rgb(${color[0]}, ${color[1]}, ${color[2]})` : "#e2e8f0"} stroke="#334155" strokeWidth={plate.mmColorId ? 1 : 0} />
      <circle cx={size / 2} cy={size / 2} r={radius} fill="none" stroke="#94a3b8" strokeDasharray="4 4" />
    </svg>
  );
}

function NotesPanel({ notes, setNotes }) {
  return (
    <div className="p-4 mt-4 rounded-2xl bg-white border border-slate-200 shadow-sm">
      <h3 className="font-semibold">Student Notebook</h3>
      <div className="mt-3 space-y-3">
        <div>
          <label className="text-sm text-slate-600">Prediction (before adding M&amp;Ms)</label>
          <textarea value={notes.predictions} onChange={(e) => setNotes((n) => ({ ...n, predictions: e.target.value }))} className="mt-1 w-full h-20 p-2 rounded-xl border border-slate-200 bg-slate-50 focus:outline-none" placeholder="I predict the dye will…" />
        </div>
        <div>
          <label className="text-sm text-slate-600">Observations</label>
          <textarea value={notes.observations} onChange={(e) => setNotes((n) => ({ ...n, observations: e.target.value }))} className="mt-1 w-full h-20 p-2 rounded-xl border border-slate-200 bg-slate-50 focus:outline-none" placeholder="On the no-sugar plate, I noticed…" />
        </div>
        <div>
          <label className="text-sm text-slate-600">Explanation (CER)</label>
          <textarea value={notes.explanations} onChange={(e) => setNotes((n) => ({ ...n, explanations: e.target.value }))} className="mt-1 w-full h-24 p-2 rounded-xl border border-slate-200 bg-slate-50 focus:outline-none" placeholder="Because particles move from high to low concentration…" />
        </div>
      </div>
    </div>
  );
}
